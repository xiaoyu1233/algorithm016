毕业总结

算法训练营给我最大的收获有三个方面：

1、大佬之所以称之为大佬来自于他所积累的知识厚度以及用知识和经验打磨出的眼界的广度。跟着大佬一起学习，可以让自己走在正确的路上。

2、无论何时无论何地，总有人在默默努力，总有人在奋发向上，我曾经最喜欢的一句话：重要的不是所站的位置，而是所朝的方向。道路千千万，愿我们总能得我们所想，爱我们所爱。

3、天才真的存在，但努力可以成就自我。我们天生的技能树千差万别，但只要刻意练习，我也可以写出漂亮的代码。虽然我现在还是有一些不自信，但我想我已经开始踏入这个领域了。

我一直畏惧code,以至于我从没走出属于我自己的一步。即使路途遥远，总有一天我能抵达终点，只要在路上，只要在前进。

写作业的同时，也写了一些博客，后两周的没有来得及更新，项目和毕业压得太紧（也是个人能力不够硬）。博客地址：https://blog.csdn.net/AI414010/article/details/109228051

以下是十周的总结汇总：

Week1

数组：

数组题常用双指针方法，有时也用到三指针，如合并有序数组题。双指针方法又有从两边向中间逼近的方法，如容器题；记录不同位置的快慢指针方法，如移动零；利用快慢特性检测环的方法，如判断环状链表。

队列：

认知到了最优队列结构，但是还没有应用。循环队列的手动实现要搭配取模技巧。

栈；
由于栈的先进后出特点，在很多场景中可以作为辅助数据结构解题，比如用迭代方法做深度优先搜索时，需要借助栈。
单调栈是一个非常有意思的结构，用来寻找数组开始上升和下降的位置，接雨水和最大矩形的题好好揣摩一下。

加油！

Week2 

本周主题是哈希、集合、树、堆。

在python中哈希的题常常可以一步到位，主要用到的库有counters。

python中堆对应的库是heapq。

在树的问题中，可以用递归和迭代两种方法。

树的后序遍历要注意初始遍历的顺序是颠倒的。

层序遍历借助的结构是队列。层序遍历的方式不适合递归的方式，但也可以用递归做，记录层数就可以。

DFS和BFS很常见，最短路径很常见，俄罗斯套娃问题，信封问题是常见题，python的Counter要用熟练。

Week3

本周课程的重点在递归和回溯。

递归和回溯都与树的结构密切相关，递归本层问题的答案或者说最优情况可以由上层问题的最优情况推到出来，与数学归纳法密切相关。没有思路可以先手推一下前几个问题的情况。

回溯题就是要遍历每一种可能的情况，然后将符合要求的答案存入结果中。

回溯题的复杂度天然存在,加速的方法就是剪枝,在遍历的同时检查可能重复的元素,尽早剪掉重复的枝.

子问题的寻找特别重要.

回溯法。

回溯法适用于每一步都需要做一次选择，每步的选择都有多种情况。

这时候回溯法要做的就是做好本层的选择，并记录层数向下递归，知道层数到达最深层，记录结果，算法结束。

写code的步骤：

1、写边界条件，如果给定的数组为空，直接返回。（这么写是为了严谨，很多时候没有检查也不会出错。

2、写递归，第一步写好终止条件，例如递归深度到达数组长度，终止，记录结果，或者返回参数。

3、递归第二步，做好本层要处理的事情，不要做多余的事情，比如本层要做一个选择，那就只做一个选择就可以。

4、递归第三步，向下递归，记录好递归深度或者带其他参数以便判断是否到达终止条件。

5、取消本步所做选择，回到上一层。

6、算法结束。

Week4

寻找半有序数组 [4, 5, 6, 7, 0, 1, 2] 中间无序的地方

在半有序数组中无序的地方即数组最大最小值的地方，题目即转化为搜索旋转排序数组中的最小值，与leetcode153同解法。

输出找到的最大值和最小值即可。

Week6

动态规划步骤：

1、寻找状态空间

状态空间的寻找非常重要，对于较基础的DP题来说，将我们需要的状态表达清楚后，基本上递推公式也很容易获得了。

2、推导递推公式

对于中等难度以上的题目来说，递推公式可能会涉及到一些数学推导和证明，这没办法，只能慢慢积累。

3、初始化base case

base case的设置非常重要，决定了递推公式是否能真正起作用。

base case的设置可以借助辅助行、辅助列来进行简化，常见于字符串的题中。

4、空间优化

通常O(n^2)的题目可以被优化到O(2n)或O(n)。

Week7

学习笔记

1、字典树和并查集都是比较固定的结构，适用的问题类型也比较固定，因此需要背熟模板。

2、高级搜索利用了一些数据原有的特性，符合人脑解决问题的思考方式，主要有双向BFS（从路径首末同时进行）、启发式搜索（充分利用先验知识）

3、红黑树和AVL树是常用的树结构，AVL树用于查询远大于插入的情况，例如微博的底层；红黑树用于插入更多的情况。因为AVL树的条件相对更加严苛，因此插入一个数据之后，需要动用大量的资源进行调整，而红黑树则相对宽松。

4、单词搜索II的Trie树实现方法的时间复杂度是O（m*m*4^k），其中m*m是网格的大小，首先在在网格中遍历寻找在字典中存在的首个字母，找到了之后需要在4个方向上进行DFS搜索，最差的情况下是4个方向都符合要求，此时无法剪枝，
k是字符串长度，每一层都需要进行4个方向的搜索，所以是4*k。但在实际搜索中，只要搜索到的路径在字典树中不存在就会被剪枝，因此搜索起来还是很快的。

Week8

本周的学习重点为3个，分别为位运算、布隆过滤器和LRU缓存、排序算法。

1、位运算的巧妙应用可以极大地提升运算时间，要熟记一些常用的位运算技巧。

2、LRU和LFU缓存的算法要记牢。

3、经典的排序算法要总结熟记，整理后上传。


